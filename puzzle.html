<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Valentine's Puzzle üß©</title>

  <!-- Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@500;600;700&family=Poppins:wght@300;400;500&display=swap" rel="stylesheet">

  <!-- Confetti -->
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>

  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: linear-gradient(-45deg, #ff9a9e, #fad0c4, #fbc2eb, #a18cd1);
      background-size: 400% 400%;
      animation: bgMove 12s ease infinite;
      font-family: "Poppins", sans-serif;
      padding: 20px;
    }

    @keyframes bgMove {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }

    .container {
      max-width: 600px;
      width: 100%;
      text-align: center;
    }

    h1 {
      font-family: "Playfair Display", serif;
      font-size: 36px;
      color: #fff;
      text-shadow: 2px 2px 8px rgba(0,0,0,0.3);
      margin-bottom: 15px;
      animation: fadeIn 1s ease;
    }

    .instructions {
      color: #fff;
      font-size: 16px;
      margin-bottom: 25px;
      text-shadow: 1px 1px 4px rgba(0,0,0,0.3);
    }

    .puzzle-wrapper {
      display: inline-block;
      background: rgba(255, 255, 255, 0.9);
      backdrop-filter: blur(18px);
      padding: 20px;
      border-radius: 20px;
      box-shadow: 0 30px 80px rgba(0,0,0,0.3);
      animation: fadeIn 1s ease 0.3s both;
    }

    .puzzle-container {
      width: min(450px, 90vw);
      height: min(450px, 90vw);
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      grid-template-rows: repeat(5, 1fr);
      gap: 3px;
      background: #ddd;
      border-radius: 12px;
      overflow: hidden;
      position: relative;
    }

    .puzzle-tile {
      background-size: 500% 500%;
      background-color: #fff;
      cursor: pointer;
      transition: all 0.2s ease;
      border: 1px solid rgba(255,255,255,0.5);
      position: relative;
    }

    .puzzle-tile:hover:not(.empty) {
      transform: scale(1.05);
      box-shadow: 0 5px 15px rgba(0,0,0,0.3);
      z-index: 10;
    }

    .puzzle-tile.empty {
      background: #f0f0f0;
      cursor: default;
      opacity: 0.3;
    }

    .controls {
      margin-top: 20px;
      display: flex;
      gap: 15px;
      justify-content: center;
      flex-wrap: wrap;
    }

    button {
      padding: 12px 28px;
      border-radius: 40px;
      border: none;
      font-size: 15px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.25s ease;
      box-shadow: 0 10px 25px rgba(0,0,0,0.15);
      background: rgba(255,255,255,0.9);
      color: #555;
    }

    button:hover {
      transform: translateY(-3px);
      box-shadow: 0 15px 30px rgba(0,0,0,0.25);
    }

    button:active {
      transform: scale(0.94);
    }

    button.primary {
      background: linear-gradient(135deg, #ff4d6d, #ff758f);
      color: #fff;
      box-shadow: 0 15px 35px rgba(255,77,109,0.4);
    }

    .move-counter {
      color: #fff;
      font-size: 18px;
      margin-top: 15px;
      text-shadow: 1px 1px 4px rgba(0,0,0,0.3);
      font-weight: 500;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    @media (max-width: 480px) {
      h1 { font-size: 28px; }
      .instructions { font-size: 14px; }
    }

    /* Upload section */
    .upload-section {
      margin-bottom: 20px;
    }

    #imageUpload {
      display: none;
    }

    .upload-label {
      display: inline-block;
      padding: 12px 28px;
      border-radius: 40px;
      background: linear-gradient(135deg, #a18cd1, #fbc2eb);
      color: #fff;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.25s ease;
      box-shadow: 0 10px 25px rgba(161,140,209,0.4);
    }

    .upload-label:hover {
      transform: translateY(-3px);
      box-shadow: 0 15px 30px rgba(161,140,209,0.6);
    }

    .preview-info {
      margin-top: 10px;
      color: #fff;
      font-size: 14px;
      text-shadow: 1px 1px 4px rgba(0,0,0,0.3);
    }
  </style>
</head>

<body>

  <div class="container">
    <h1>üíù Solve the Puzzle üíù</h1>
    <p class="instructions">Slide the tiles to complete the image!</p>

    <div class="upload-section">
      <label for="imageUpload" class="upload-label">üì∑ Upload Your Image</label>
      <input type="file" id="imageUpload" accept="image/*">
      <div class="preview-info" id="previewInfo"></div>
    </div>

    <div class="puzzle-wrapper">
      <div class="puzzle-container" id="puzzleContainer"></div>
    </div>

    <div class="controls">
      <button onclick="shufflePuzzle()">üîÄ Shuffle</button>
      <button onclick="resetPuzzle()">üîÑ Reset</button>
      <button class="primary" onclick="showHint()">üí° Hint</button>
    </div>

    <div class="move-counter">Moves: <span id="moveCount">0</span></div>
  </div>

  <script>
    const GRID_SIZE = 5;
    let tiles = [];
    let emptyPos = { row: GRID_SIZE - 1, col: GRID_SIZE - 1 };
    let moves = 0;
    let imageUrl = '';
    let puzzleInitialized = false;

    // Default image (you can replace this with your own)
    const defaultImage = 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" width="500" height="500"%3E%3Cdefs%3E%3ClinearGradient id="grad" x1="0%25" y1="0%25" x2="100%25" y2="100%25"%3E%3Cstop offset="0%25" style="stop-color:%23ff9a9e;stop-opacity:1" /%3E%3Cstop offset="100%25" style="stop-color:%23fad0c4;stop-opacity:1" /%3E%3C/linearGradient%3E%3C/defs%3E%3Crect width="500" height="500" fill="url(%23grad)"/%3E%3Ctext x="250" y="250" font-family="Arial" font-size="80" fill="white" text-anchor="middle" dominant-baseline="middle"%3E‚ù§Ô∏è US ‚ù§Ô∏è%3C/text%3E%3C/svg%3E';

    // Initialize with default image
    imageUrl = defaultImage;
    initializePuzzle();

    // Handle image upload
    document.getElementById('imageUpload').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = function(event) {
          imageUrl = event.target.result;
          document.getElementById('previewInfo').textContent = `‚úì ${file.name} loaded!`;
          initializePuzzle();
          shufflePuzzle();
        };
        reader.readAsDataURL(file);
      }
    });

    function initializePuzzle() {
      const container = document.getElementById('puzzleContainer');
      container.innerHTML = '';
      tiles = [];
      
      for (let row = 0; row < GRID_SIZE; row++) {
        tiles[row] = [];
        for (let col = 0; col < GRID_SIZE; col++) {
          const tile = document.createElement('div');
          tile.className = 'puzzle-tile';
          tile.dataset.row = row;
          tile.dataset.col = col;
          
          if (row === GRID_SIZE - 1 && col === GRID_SIZE - 1) {
            tile.classList.add('empty');
          } else {
            const bgPosX = (col / (GRID_SIZE - 1)) * 100;
            const bgPosY = (row / (GRID_SIZE - 1)) * 100;
            tile.style.backgroundImage = `url(${imageUrl})`;
            tile.style.backgroundPosition = `${bgPosX}% ${bgPosY}%`;
          }
          
          tile.addEventListener('click', () => moveTile(row, col));
          container.appendChild(tile);
          tiles[row][col] = tile;
        }
      }
      
      moves = 0;
      updateMoveCounter();
      puzzleInitialized = true;
    }

    function moveTile(row, col) {
      const rowDiff = Math.abs(row - emptyPos.row);
      const colDiff = Math.abs(col - emptyPos.col);
      
      if ((rowDiff === 1 && colDiff === 0) || (rowDiff === 0 && colDiff === 1)) {
        // Swap tiles
        const clickedTile = tiles[row][col];
        const emptyTile = tiles[emptyPos.row][emptyPos.col];
        
        // Swap background images
        const tempBg = clickedTile.style.backgroundImage;
        const tempBgPos = clickedTile.style.backgroundPosition;
        
        clickedTile.style.backgroundImage = emptyTile.style.backgroundImage;
        clickedTile.style.backgroundPosition = emptyTile.style.backgroundPosition;
        clickedTile.classList.add('empty');
        
        emptyTile.style.backgroundImage = tempBg;
        emptyTile.style.backgroundPosition = tempBgPos;
        emptyTile.classList.remove('empty');
        
        tiles[row][col] = emptyTile;
        tiles[emptyPos.row][emptyPos.col] = clickedTile;
        
        emptyPos = { row, col };
        moves++;
        updateMoveCounter();
        
        checkWin();
      }
    }

    function shufflePuzzle() {
      // Make 100 random valid moves
      for (let i = 0; i < 100; i++) {
        const validMoves = [];
        
        if (emptyPos.row > 0) validMoves.push({ row: emptyPos.row - 1, col: emptyPos.col });
        if (emptyPos.row < GRID_SIZE - 1) validMoves.push({ row: emptyPos.row + 1, col: emptyPos.col });
        if (emptyPos.col > 0) validMoves.push({ row: emptyPos.row, col: emptyPos.col - 1 });
        if (emptyPos.col < GRID_SIZE - 1) validMoves.push({ row: emptyPos.row, col: emptyPos.col + 1 });
        
        const randomMove = validMoves[Math.floor(Math.random() * validMoves.length)];
        moveTile(randomMove.row, randomMove.col);
      }
      
      moves = 0;
      updateMoveCounter();
    }

    function resetPuzzle() {
      initializePuzzle();
    }

    function showHint() {
      alert('üí° Tip: Work on completing one row or column at a time, starting from the top-left corner!');
    }

    function updateMoveCounter() {
      document.getElementById('moveCount').textContent = moves;
    }

    function checkWin() {
      let solved = true;
      
      for (let row = 0; row < GRID_SIZE; row++) {
        for (let col = 0; col < GRID_SIZE; col++) {
          const tile = tiles[row][col];
          if (parseInt(tile.dataset.row) !== row || parseInt(tile.dataset.col) !== col) {
            solved = false;
            break;
          }
        }
        if (!solved) break;
      }
      
      if (solved) {
        confetti({
          particleCount: 300,
          spread: 150,
          origin: { y: 0.6 }
        });
        
        setTimeout(() => {
          const proceed = confirm(`üéâ Amazing! You solved it in ${moves} moves!\n\nReady for your special surprise? üíï`);
          if (proceed) {
            window.location.href = 'final.html';
          }
        }, 500);
      }
    }

    // Auto-shuffle on load after a delay
    setTimeout(() => {
      if (puzzleInitialized) {
        shufflePuzzle();
      }
    }, 1000);
  </script>

</body>
</html>
